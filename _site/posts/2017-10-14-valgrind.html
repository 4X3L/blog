<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Alex Benishek - Valgrind</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="icon" href="../favicon.png">
    </head>
    <body>
        <div id="header">
          <a href="../" id="header-name">Alex Benishek</a>
          <ul id="header-list">
            <li><a href="../about.html">About</a></li>
            <li><a href="../contact.html">Contact</a></li>
            <li><a href="https://www.gnu.org/licenses/fdl-1.3-standalone.html">License</a></li>
            <li><a href="https://github.com/4X3L/blog/">Source</a></li>
          </ul>
        </div>

        <div id="container">
            <h1>Valgrind</h1>
<p><a href="http://valgrind.org/">Valgrind</a> is a great tool and makes programming in C so much easier.</p>
<p>The first roadblock would-be C programmers face is the dreaded “Segmentation fault (core dumped)”. This is about as helpful as a message saying, “Screw you, programmer!”. However, valgrind will tell you where what went wrong when in your code. Allowing you as the programmer to start debugging.</p>
<p>Consider the following obviously broken code.</p>
<pre><code>#include &lt;stdio.h&gt;

int main() {
  int *x = NULL;
  printf(&quot;%d\n&quot;, *x);
}</code></pre>
<p>Compiling with the command</p>
<pre><code>gcc main.c -o main</code></pre>
<p>Then running the program will producing a segmentation fault. Lets now try running it with valgrind.</p>
<pre><code>valgrind ./main</code></pre>
<p>There will be a lot of output but look for this section</p>
<pre><code>==22201== Invalid read of size 4
==22201==    at 0x4004EB: main (in /.../main)
==22201==  Address 0x0 is not stack'd, malloc'd or (recently) free'd</code></pre>
<p>The specifics on your computer might be different but if will look similar. The first line tells us we tried to read four bytes from memory when we shouldn’t have. That makes sense because on my machine an <code>int</code> is four bytes. The final line gives us the address of the read. Again, this is what we would expect since we tried to dereference a null pointer and on most architectures a null pointer will be a pointer to the memory address zero. The third line is trying to tell us where in the original source code the invalid read occurred but it does not know since we did not compile with debug symbols. Lets change that.</p>
<pre><code>gcc main.c -g -o main</code></pre>
<p>After running valgrind for a second time we will see the line now tells use where in the code the error occurred.</p>
<pre><code>==22291==    at 0x4004EB: main (main.c:5)</code></pre>
<p>Now it is saying that the error occurred on line five in <code>main.c</code>. Now that we know where the error is occurring we can fire up <code>gdb</code> and take a closer look at whats happening.</p>
<p>This post is incredibly basic and there is so much more to valgrind but for a beginner programmer this will be the most useful part. In a later post on memory management I will also use it to detect when memory is not freed but also not being used.</p>

        </div>

        <div id="footer">
          <div id="copyright">&copy; 2017 Alex Benishek</div>
          <div id="license_notice">The content of this site is licensed under the <a href="https://www.gnu.org/licenses/fdl-1.3-standalone.html">GNU Free Documentation License</a> unless otherwise noted. </div>
          <div id="generated">
          Site proudly generated by
          <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
