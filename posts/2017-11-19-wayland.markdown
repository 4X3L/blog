---
title: Getting Started with Wayland
description: Example code for how code a client for Wayland, the replacement for X11.
---

In this post I will give an overview of how Wayland on Linux works and then provide source code in a "literate" style where a large block of text preceds a small code segment. This post will only provide a summary of the full code that is on my [github](https://github.com/4X3L/example-wayland). Mainly I will be omitting repetitive code and error checking.

Before I start, I want to cite the resources I used in writing this post.

- [The official Wayland documentation](https://wayland.freedesktop.org/docs/html/)

- [Github user hdante's hello_wayland](https://github.com/hdante/hello_wayland/)

- [The Wayland source code, extremely readable](https://cgit.freedesktop.org/wayland/wayland/tree/)

- [The weston client example](https://github.com/wayland-project/weston/blob/master/clients/)

- [Jan Newmarch's "Programming Wayland Clients"](https://jan.newmarch.name/Wayland/index.html), however, this is unfinished and contains errors

Also, the code on this page and in the repository is licenced under the MIT License and not the GNU Free Document License. 

When first looking at Wayland the most confusing thing for many people is that there are two main parts, a "meta-protocol"
that can be used to define a "concrete-protocol" that the client
and server use to communicate. The "meta-protocol" sets up a pipe between the client
and server while the "concrete-protocol" determines what is sent throught the pipe.
Since the client and server comunicate through discrete messages, all mesages have a
generic reprsentation. This generic representation is a struct called "wl_proxy".
Most client functions have the form "wl_OBJECT_METHOD" and are thin, type safe
wrappers around "wl_proxy_METHOD". We would like some type safety so we wrap all proxy
methods in a type safe wrapper. Likewise, most struct pointer of the form
"struct wl_OBJECT *" are opaque pointers that are actually pointing to some wl_proxy
struct. Because of this things like, many functions like
"wl_registry_add_listener" and "wl_registry_bind" do not have definitions in 
wayland-client.c. Instead, they are found in an xml file in "protocol/wayland.xml"
in the wayland source code. At build time this xml file is used to automatically
generate wrapper functions around wl_proxy functions. 
generate a concrete protocol that our client will use to actually communicate 
with the server.

My code and the wayland API is all in C so you may be confused by the talk of objects
and methods. Despite being written in C wayland is actually an object oriented API.
The objects are called "interfaces". The general form of the methods is
"<Wayland Namespace>_<Interface Name>_<Method Name>" so when we write this

    struct wl_registry *registry = wl_display_get_registry(...);
    wl_registry_bind(registry, ...);

it would look like this in some imaginary C++ API:

    wl::registry reg = display.get_registry(...);
    reg.bind(...); 

The first argument to a method is a pointer to the instance variables. The rest are
the arguments to the method.

Since the API uses asynchronous message passing to communicate between client and
server we send callbacks to respond to events generated by the server. However, once
our code runs we'd like to store the result somewhere. So, when adding a callback we
also add a pointer so some struct which acts as the "instance variables". Any callback
attached to the object will be sent a pointer to that struct as its first arguments.

For example, we give wl_output a pointer to this struct

    struct output_info
    {
      int32_t width;
      int32_t height;
      int32_t hertz;
    };

in order to record information about a monitor. Another example of this is the usage
of the "registry_objects" struct in the wayland registry. The registry will be
explained once we get to that point in the code. Speaking of code, let's start showing some.

I took the code on my github and stripped out all of the error checking code and
resource freeing. So this is not how you would exactly want to code this program, but
it should give you a better idea of how the Wayland client API works. I also put the main function before the function and struct defintitions.

This program also does not handle keyboard or mouse input. However, once you
understand how this program works and look at the Wayland documentation hopefully it
will not be two hard to add that. 

    int
    main () 
    {

There is a socket on the filesystem somewhere that programs can use to 
communicate with the wayland server. We want to connect to that socket.
We can specify a specific socket to use be we just want the default one
so we pass in NULL. This returns an opaque pointer to an object 
representing our connection to the wayland server.

This object is probably poorly named because it is not really a "display" in
the sense of a single computer screen or monitor, instead this struct 
represents a connection to the server from our client. It is firstly used to 
create the pipe between this client and the sever and secondly, is used to
get the wl_registry, which is used to get access to all of the devices we
care about
      
      struct wl_display *display = wl_display_connect(NULL);

A struct containing pointers to objects we want to get out of the registry.
We'll pass a pointer to this so that the registry_listener callaback will
access to this object.

      struct registry_objects objs;

Info about each monitor explicitly the width, height, and refresh rate.

      struct output_info output_info[MAX_OUTPUT];

Initialize the local variables.

      memset (&objs, 0, sizeof(objs));
      memset (&output_info, 0, sizeof (struct output_info) * MAX_OUTPUT);
    
The registry contains a list of all objects that the server knows about. So
if we want to get access to the mointor, keyboard, or mouse we have to go
through the registry.

      struct wl_registry *registry = wl_display_get_registry (display);
     
Since the function pointer we give does not explictly return anyting we give 
share a "registry_objects" struct betweenn the wl_registry and the main 
function. The callback will set the contents of objs.

      wl_registry_add_listener (registry, &registry_listener, &objs);
    
Messages created by our client are initially just queued to be sent but are
not actually sent. For exaple, wl_registry_add_listener will add an event to the
queue but will not actually notify the server directly. "wl_display_dispatch" 
will send all of the messages in the queue to the server.

wl_display_roundtrip will just sit and wait for the server's response.
Wayland is an asyncronous API so normally we wouldn't want to wait for the
server response but in this case we can't do anything until we have the
compositor anyhow so we might as well wait

      wl_display_roundtrip (display);

Add callback to each output object.

      for (size_t i = 0; i < objs.output_num; i++)
         wl_output_add_listener (objs.outputs[i], &output_listener, &output_info[i]);
    
The listener we added won't be triggered until we  actually read events
Important to remember that if a callback segfaults, gdb will have problems 
telling you exactly where the segfault occured.

Wait for server to aknowledge our message.

      wl_display_roundtrip (display);
      
      for (size_t i = 0; i < objs.output_num; i++)
        printf ("Monitor resolution: %d pixels by %d pixels at %dmHz\n",
                output_info[i].width, output_info[i].height, output_info[i].hertz);
    
We'd like to use the shm object to create a shared memory pool and then use
the shared memory pool to create frame buffers that we can then use to
acutally display things, but we need to know the size of the monitors in
order to know how much memory to allocate. We don't know which monitor the
user wants the  display to be on. We might also want to deal with
"hotswapping" monitors. We will have to do something smarter than this in a
real program but for now we will arbitrarily choose a monitor.

First we need to create an in memory "file". We then us mmap to turn that
"file" into an actual memory buffer. 

This creates an acutal file in the file system so if we run two instances of 
the program at the same time this will fail, except maybe not? The O_CREAT
flag might create a object with new name

      int mem_fd = shm_open ("/unknown_animal_wayland_frame_buffer",
                             O_RDWR | O_CREAT, S_IRUSR | S_IWUSR );
      
      const size_t width = output_info[0].width;
      const size_t height = output_info[0].height;
      const size_t num_px = width * height;
      const size_t fb_bs = num_px * sizeof (struct pixel);
            
      struct pixel *raw_pixels =
        mmap (NULL, fb_bs, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd,  0);
      
      struct wl_shm_pool *pool = wl_shm_create_pool(objs.shm, mem_fd, fb_bs);
    
Next that we have a chunk of shared memory and put it into a wl_shm_pool, we
need to create a buffer from that pool and then bind that buffer to a
surface.

Once that is done we should, fingers crossed, be able to display that surface
on the screen.
      
A surface is just some rectangualar grid that the client can draw on

      struct wl_surface *surface = wl_compositor_create_surface (objs.comp);

A shell surface is like a surface but it is provided by the graphical shell 
that started the client program. I am not fully certain of the rational
behind having a distinction between a shell_surface and a normal surfae.

      struct wl_shell_surface *shell_surface = wl_shell_get_shell_surface (objs.shell, surface)
    
      wl_shell_surface_add_listener (shell_surface, &shell_surface_listener, 0);
    
      struct wl_buffer *way_fb =
        wl_shm_pool_create_buffer (pool, 0,
                                   output_info[0].width,
                                   output_info[0].height,
                                   output_info[0].width * sizeof(struct pixel),
                                   WL_SHM_FORMAT_ARGB8888);
      
      wl_shell_surface_set_fullscreen (shell_surface,
                                       WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT,
                                       output_info[0].hertz, objs.outputs[0]);
    
      wl_shell_surface_set_title (shell_surface, "Wayland Example");
    
Wait for half a second before drawing the next frame. In a real program we
would be updating the time every frame and limit the frame rate, but pausing
for half a second every frame works and gets the point across.
     
      struct timespec sleep;
      sleep.tv_nsec = 500000000;
      sleep.tv_sec = 0;
    
      for (uint32_t frame_num; frame_num < 10; frame_num++)
        {

Simple rendering, strobe effect. In a real program this is where we would
do the rendering.

          uint8_t red = ((frame_num % 3) == 0) * 255;
          uint8_t green = ((frame_num % 3) == 1) * 255;
          uint8_t blue = ((frame_num % 3) == 2) * 255;
    
          for (uint32_t i = 0; i < num_px; i++)
            {
              raw_pixels[i].r = red;
              raw_pixels[i].g = green;
              raw_pixels[i].b = blue;
            }
          
Set the new contents of the surface

          wl_surface_attach (surface, way_fb, 0, 0);
          
Specify what area to redraw, in this case the entire thing.

          wl_surface_damage (surface, 0, 0, width, height);
    
All wayland surfaces are double buffered by the server. So if we make a 
change to the backing array of data that change will not be visible until
calling wl_surface_commit, at which point the server will replace what it
displays to the user with the updated buffer

          wl_surface_commit (surface);
    
Normal wl_display_dispatch will wait to recieve a message if there is not
one from the server. wl_display_dispatch pending not block on no messages

          wl_display_dispatch_pending (display)
    
Send messages from the client to the server

          wl_display_flush (display)
    
          nanosleep (&sleep, NULL);
       }
    }

Here are the definitions of the callbacks and structs we used in the main function.

The layout of the pixels is little endian, so we layout the pixels in the reverse
order of what you'd expect

    struct pixel
    {
      uint8_t b;
      uint8_t g;
      uint8_t r;
      uint8_t a;
    };
    
The API operates asynchronously so in order to get information about a display
we have to create a callback which sets the data we want and then we send that
callback to the server and wait for a response.

    struct output_info
    {      
      int32_t width;
      int32_t height;
      int32_t hertz;
    };
    
If we specify one callback to run once an event starts then we have to specify
all events that the object supports. So we will want to give a dummy callback
that does nothing.

    static void do_nothing () {}
    
    static void
    output_mode_cb (void *data, struct wl_output *out, uint32_t flags,
                    int32_t width, int32_t height, int32_t refresh_rate)
    {
      (void) flags;
      (void) out;
      struct output_info *info = data;
      info->width = width;
      info->height = height;
      info->hertz = refresh_rate;
    }
    
    static const struct wl_output_listener output_listener = 
      {
        do_nothing,
        output_mode_cb,
        do_nothing,
        do_nothing,
      };
The important part of adding listeners is that you add the listener of a
message before reading the message. As long as you add the listener before
reading the message in the main loop the callback will still trigger so even
though the client recieved the message from the server, the imporant part is
not reading it until client is ready.
   
Thanks to SardemFF7 on #wayland IRC for explaining that


These are the user fields of the registry object. This object provides a way to
access the other objects

    struct registry_objects
    {
      struct wl_compositor *comp;

A block of unused memory shared between server and client. Sub-blocks are
carved out of this block to form buffers

      struct wl_shm *shm;
      
"shell" refers to the graphical shell which our program is managed by.

      struct wl_shell *shell;
      
A "seat", described in the documentation as a collection of keyboard,
monitors, and "pointer" (mouse, stylus, or finger) devices. I *think* the
idea is that if you have multiple thin graphical clients connected to a
server that you want the mouse and keyboard and monitor that are all in some
way "associated" together. So in the case of clients, the devices all
associated with the same thin client

      struct wl_seat *seat;

There could be multiple monitors (wl_output) so we need to have an array of 
monitors

      struct wl_output *outputs[MAX_OUTPUT];
      
The number of monitors actually used

      uint32_t output_num;
    };
    
    
Whenever something is added to the registry our program will be notified by 
wayland running this callback

    static void
    global_registry_handler (void *data, 

Pointer to registry this method was called on

                             struct wl_registry *registry,
                             
Wayland ID is the "name" of object that became visible. It is unique.

                             uint32_t id,

The text name of object that became visible

                             const char *interface,

The version of the object that became visible

                             uint32_t version) 
    {
      struct registry_objects *objs = data;
      printf("Got a registry event for %s id %d version %d \n", interface, id, version);
      if (strcmp(interface, wl_compositor_interface.name) == 0)
        objs->comp = wl_registry_bind(registry, id, &wl_compositor_interface, 1);
        
The above code takes the registry called "registry" and associates the name
id with the object wl_compositor_interface. Also, we are using version 1 of 
the API

      else if (strcmp(interface, wl_shell_interface.name) == 0)
        objs->shell = wl_registry_bind(registry, id, &wl_shell_interface, 1);
      else if (strcmp(interface, wl_shm_interface.name) == 0)
        objs->shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
      else if (strcmp(interface, wl_seat_interface.name) == 0)
        objs->seat = wl_registry_bind(registry, id, &wl_seat_interface, 1);
        
Get all outputs, in the case that there are multiple monitors

      else if (strcmp(interface, wl_output_interface.name) == 0)
        if (objs->output_num < MAX_OUTPUT)
          {
            objs->outputs[objs->output_num] = wl_registry_bind(registry, id, &wl_output_interface, 1);
            objs->output_num++;
          }
    }
    
The registry expects a pair of callbacks, one for when an object is created,
the other for when it is destroyed. The pair is wrapped in a struct.

    static const struct wl_registry_listener registry_listener = 
      {
        global_registry_handler,
        do_nothing,
      };
    
In order to know if a client has become unresponsive the server will send
"ping" messages and the client needs to repond with "pong" or the client will
be deemed to be unresponsive

    static void
    ping_cb (void *data, struct wl_shell_surface *shell_surface, uint32_t serial)
    {
      (void) data;
      wl_shell_surface_pong (shell_surface, serial);
    }
    
    static const struct wl_shell_surface_listener shell_surface_listener = 
      {
        ping_cb,
        do_nothing,
        do_nothing
      };
